{"version":3,"file":"flowGraphSetDelayBlock-BkZ3fOe4.js","sources":["../../node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.js"],"sourcesContent":["import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock.js\";\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes.js\";\nimport { AdvancedTimer } from \"../../../../Misc/timer.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block that sets a delay in seconds before activating the output signal.\n */\nexport class FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {\n    constructor(config) {\n        super(config);\n        this.cancel = this._registerSignalInput(\"cancel\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.lastDelayIndex = this.registerDataOutput(\"lastDelayIndex\", RichTypeNumber, -1);\n    }\n    _preparePendingTasks(context) {\n        const duration = this.duration.getValue(context);\n        if (duration < 0 || isNaN(duration) || !isFinite(duration)) {\n            return this._reportError(context, \"Invalid duration in SetDelay block\");\n        }\n        // active delays are global to the context\n        const activeDelays = context._getGlobalContextVariable(\"activeDelays\", 0);\n        if (activeDelays >= FlowGraphSetDelayBlock.MaxParallelDelayCount) {\n            return this._reportError(context, \"Max parallel delays reached\");\n        }\n        // get the last global delay index\n        const lastDelayIndex = context._getGlobalContextVariable(\"lastDelayIndex\", -1);\n        // these are block-specific and not global\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const scene = context.configuration.scene;\n        const timer = new AdvancedTimer({\n            timeout: duration * 1000, // duration is in seconds\n            contextObservable: scene.onBeforeRenderObservable,\n            onEnded: () => this._onEnded(timer, context),\n        });\n        timer.start();\n        const newIndex = lastDelayIndex + 1;\n        this.lastDelayIndex.setValue(newIndex, context);\n        context._setGlobalContextVariable(\"lastDelayIndex\", newIndex);\n        timers[newIndex] = timer;\n        context._setExecutionVariable(this, \"pendingDelays\", timers);\n    }\n    _cancelPendingTasks(context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        for (const timer of timers) {\n            timer?.dispose();\n        }\n        context._deleteExecutionVariable(this, \"pendingDelays\");\n        this.lastDelayIndex.setValue(-1, context);\n    }\n    _execute(context, callingSignal) {\n        if (callingSignal === this.cancel) {\n            this._cancelPendingTasks(context);\n            return;\n        }\n        else {\n            this._preparePendingTasks(context);\n            this.out._activateSignal(context);\n        }\n    }\n    getClassName() {\n        return \"FlowGraphSetDelayBlock\" /* FlowGraphBlockNames.SetDelay */;\n    }\n    _onEnded(timer, context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const index = timers.indexOf(timer);\n        if (index !== -1) {\n            timers.splice(index, 1);\n        }\n        else {\n            Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n        }\n        context._removePendingBlock(this);\n        this.done._activateSignal(context);\n    }\n}\n/**\n * The maximum number of parallel delays that can be set per node.\n */\nFlowGraphSetDelayBlock.MaxParallelDelayCount = 100;\nRegisterClass(\"FlowGraphSetDelayBlock\" /* FlowGraphBlockNames.SetDelay */, FlowGraphSetDelayBlock);\n//# sourceMappingURL=flowGraphSetDelayBlock.js.map"],"names":["FlowGraphSetDelayBlock","FlowGraphAsyncExecutionBlock","config","RichTypeNumber","context","duration","lastDelayIndex","timers","scene","timer","AdvancedTimer","newIndex","callingSignal","index","Logger","RegisterClass"],"mappings":"oEAQO,MAAMA,UAA+BC,CAA6B,CACrE,YAAYC,EAAQ,CAChB,MAAMA,CAAM,EACZ,KAAK,OAAS,KAAK,qBAAqB,QAAQ,EAChD,KAAK,SAAW,KAAK,kBAAkB,WAAYC,CAAc,EACjE,KAAK,eAAiB,KAAK,mBAAmB,iBAAkBA,EAAgB,EAAE,CACtF,CACA,qBAAqBC,EAAS,CAC1B,MAAMC,EAAW,KAAK,SAAS,SAASD,CAAO,EAC/C,GAAIC,EAAW,GAAK,MAAMA,CAAQ,GAAK,CAAC,SAASA,CAAQ,EACrD,OAAO,KAAK,aAAaD,EAAS,oCAAoC,EAI1E,GADqBA,EAAQ,0BAA0B,eAAgB,CAAC,GACpDJ,EAAuB,sBACvC,OAAO,KAAK,aAAaI,EAAS,6BAA6B,EAGnE,MAAME,EAAiBF,EAAQ,0BAA0B,iBAAkB,EAAE,EAEvEG,EAASH,EAAQ,sBAAsB,KAAM,gBAAiB,CAAA,CAAE,EAChEI,EAAQJ,EAAQ,cAAc,MAC9BK,EAAQ,IAAIC,EAAc,CAC5B,QAASL,EAAW,IACpB,kBAAmBG,EAAM,yBACzB,QAAS,IAAM,KAAK,SAASC,EAAOL,CAAO,CACvD,CAAS,EACDK,EAAM,MAAK,EACX,MAAME,EAAWL,EAAiB,EAClC,KAAK,eAAe,SAASK,EAAUP,CAAO,EAC9CA,EAAQ,0BAA0B,iBAAkBO,CAAQ,EAC5DJ,EAAOI,CAAQ,EAAIF,EACnBL,EAAQ,sBAAsB,KAAM,gBAAiBG,CAAM,CAC/D,CACA,oBAAoBH,EAAS,CACzB,MAAMG,EAASH,EAAQ,sBAAsB,KAAM,gBAAiB,CAAA,CAAE,EACtE,UAAWK,KAASF,EAChBE,GAAO,QAAO,EAElBL,EAAQ,yBAAyB,KAAM,eAAe,EACtD,KAAK,eAAe,SAAS,GAAIA,CAAO,CAC5C,CACA,SAASA,EAASQ,EAAe,CAC7B,GAAIA,IAAkB,KAAK,OAAQ,CAC/B,KAAK,oBAAoBR,CAAO,EAChC,MACJ,MAEI,KAAK,qBAAqBA,CAAO,EACjC,KAAK,IAAI,gBAAgBA,CAAO,CAExC,CACA,cAAe,CACX,MAAO,wBACX,CACA,SAASK,EAAOL,EAAS,CACrB,MAAMG,EAASH,EAAQ,sBAAsB,KAAM,gBAAiB,CAAA,CAAE,EAChES,EAAQN,EAAO,QAAQE,CAAK,EAC9BI,IAAU,GACVN,EAAO,OAAOM,EAAO,CAAC,EAGtBC,EAAO,KAAK,+EAA+E,EAE/FV,EAAQ,oBAAoB,IAAI,EAChC,KAAK,KAAK,gBAAgBA,CAAO,CACrC,CACJ,CAIAJ,EAAuB,sBAAwB,IAC/Ce,EAAc,yBAA6Df,CAAsB","x_google_ignoreList":[0]}