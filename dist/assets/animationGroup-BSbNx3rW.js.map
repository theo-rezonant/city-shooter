{"version":3,"file":"animationGroup-BSbNx3rW.js","sources":["../../node_modules/@babylonjs/core/Animations/animationGroup.js"],"sourcesContent":["import { Animation } from \"./animation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport \"./animatable.js\";\n/**\n * This class defines the direct association between an animation and a target\n */\nexport class TargetedAnimation {\n    /**\n     * Returns the string \"TargetedAnimation\"\n     * @returns \"TargetedAnimation\"\n     */\n    getClassName() {\n        return \"TargetedAnimation\";\n    }\n    /**\n     * Serialize the object\n     * @returns the JSON object representing the current entity\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.animation = this.animation.serialize();\n        serializationObject.targetId = this.target.id;\n        return serializationObject;\n    }\n}\n/**\n * Use this class to create coordinated animations on multiple targets\n */\nexport class AnimationGroup {\n    /**\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\n     */\n    get mask() {\n        return this._mask;\n    }\n    set mask(value) {\n        if (this._mask === value) {\n            return;\n        }\n        this._mask = value;\n        this.syncWithMask(true);\n    }\n    /**\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\n     * Note however that the call won't have any effect if the animation group has not been started yet.\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\n     */\n    syncWithMask(forceUpdate = false) {\n        if (!this.mask && !forceUpdate) {\n            this._numActiveAnimatables = this._targetedAnimations.length;\n            return;\n        }\n        this._numActiveAnimatables = 0;\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\n                this._numActiveAnimatables++;\n                if (animatable.paused) {\n                    animatable.restart();\n                }\n            }\n            else {\n                if (!animatable.paused) {\n                    animatable.pause();\n                }\n            }\n        }\n    }\n    /**\n     * Removes all animations for the targets not retained by the animation group mask.\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\n     */\n    removeUnmaskedAnimations() {\n        if (!this.mask || this.mask.disabled) {\n            return;\n        }\n        // Removes all animatables (in case the animation group has already been started)\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask.retainsTarget(animatable.target.name)) {\n                animatable.stop();\n                this._animatables.splice(i, 1);\n                --i;\n            }\n        }\n        // Removes the targeted animations\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\n                this._targetedAnimations.splice(index, 1);\n                --index;\n            }\n        }\n    }\n    /**\n     * Gets or sets the first frame\n     */\n    get from() {\n        return this._from;\n    }\n    set from(value) {\n        if (this._from === value) {\n            return;\n        }\n        this._from = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.fromFrame = this._from;\n        }\n    }\n    /**\n     * Gets or sets the last frame\n     */\n    get to() {\n        return this._to;\n    }\n    set to(value) {\n        if (this._to === value) {\n            return;\n        }\n        this._to = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.toFrame = this._to;\n        }\n    }\n    /**\n     * Define if the animations are started\n     */\n    get isStarted() {\n        return this._isStarted;\n    }\n    /**\n     * Gets a value indicating that the current group is playing\n     */\n    get isPlaying() {\n        return this._isStarted && !this._isPaused;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    set speedRatio(value) {\n        if (this._speedRatio === value) {\n            return;\n        }\n        this._speedRatio = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.speedRatio = this._speedRatio;\n        }\n    }\n    /**\n     * Gets or sets if all animations should loop or not\n     */\n    get loopAnimation() {\n        return this._loopAnimation;\n    }\n    set loopAnimation(value) {\n        if (this._loopAnimation === value) {\n            return;\n        }\n        this._loopAnimation = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.loopAnimation = this._loopAnimation;\n        }\n    }\n    /**\n     * Gets or sets if all animations should be evaluated additively\n     */\n    get isAdditive() {\n        return this._isAdditive;\n    }\n    set isAdditive(value) {\n        if (this._isAdditive === value) {\n            return;\n        }\n        this._isAdditive = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.isAdditive = this._isAdditive;\n        }\n    }\n    /**\n     * Gets or sets the weight to apply to all animations of the group\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (this._weight === value) {\n            return;\n        }\n        this._weight = value;\n        this.setWeightForAllAnimatables(this._weight);\n    }\n    /**\n     * Gets the targeted animations for this animation group\n     */\n    get targetedAnimations() {\n        return this._targetedAnimations;\n    }\n    /**\n     * returning the list of animatables controlled by this animation group.\n     */\n    get animatables() {\n        return this._animatables;\n    }\n    /**\n     * Gets the list of target animations\n     */\n    get children() {\n        return this._targetedAnimations;\n    }\n    /**\n     * Gets or sets the order of play of the animation group (default: 0)\n     */\n    get playOrder() {\n        return this._playOrder;\n    }\n    set playOrder(value) {\n        if (this._playOrder === value) {\n            return;\n        }\n        this._playOrder = value;\n        if (this._animatables.length > 0) {\n            for (let i = 0; i < this._animatables.length; i++) {\n                this._animatables[i].playOrder = this._playOrder;\n            }\n            this._scene.sortActiveAnimatables();\n        }\n    }\n    /**\n     * Allows the animations of the animation group to blend with current running animations\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\n     */\n    get enableBlending() {\n        return this._enableBlending;\n    }\n    set enableBlending(value) {\n        if (this._enableBlending === value) {\n            return;\n        }\n        this._enableBlending = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.enableBlending = value;\n            }\n        }\n    }\n    /**\n     * Gets or sets the animation blending speed\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\n     */\n    get blendingSpeed() {\n        return this._blendingSpeed;\n    }\n    set blendingSpeed(value) {\n        if (this._blendingSpeed === value) {\n            return;\n        }\n        this._blendingSpeed = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.blendingSpeed = value;\n            }\n        }\n    }\n    /**\n     * Gets the length (in seconds) of the animation group\n     * This function assumes that all animations are played at the same framePerSecond speed!\n     * Note: you can only call this method after you've added at least one targeted animation!\n     * @param from Starting frame range (default is AnimationGroup.from)\n     * @param to Ending frame range (default is AnimationGroup.to)\n     * @returns The length in seconds\n     */\n    getLength(from, to) {\n        from = from ?? this._from;\n        to = to ?? this._to;\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\n        return (to - from) / fps;\n    }\n    /**\n     * Merge the array of animation groups into a new animation group\n     * @param animationGroups List of animation groups to merge\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\n     * @returns The new animation group or null if no animation groups were passed\n     */\n    static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {\n        if (animationGroups.length === 0) {\n            return null;\n        }\n        weight = weight ?? animationGroups[0].weight;\n        let beginFrame = Number.MAX_VALUE;\n        let endFrame = -Number.MAX_VALUE;\n        if (normalize) {\n            for (const animationGroup of animationGroups) {\n                if (animationGroup.from < beginFrame) {\n                    beginFrame = animationGroup.from;\n                }\n                if (animationGroup.to > endFrame) {\n                    endFrame = animationGroup.to;\n                }\n            }\n        }\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\n        for (const animationGroup of animationGroups) {\n            if (normalize) {\n                animationGroup.normalize(beginFrame, endFrame);\n            }\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\n            }\n            if (disposeSource) {\n                animationGroup.dispose();\n            }\n        }\n        return mergedAnimationGroup;\n    }\n    /**\n     * Instantiates a new Animation Group.\n     * This helps managing several animations at once.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n     * @param name Defines the name of the group\n     * @param scene Defines the scene the group belongs to\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\n     * @param playOrder Defines the order of play of the animation group (default is 0)\n     */\n    constructor(\n    /** The name of the animation group */\n    name, scene = null, weight = -1, playOrder = 0) {\n        this.name = name;\n        this._targetedAnimations = new Array();\n        this._animatables = new Array();\n        this._from = Number.MAX_VALUE;\n        this._to = -Number.MAX_VALUE;\n        this._speedRatio = 1;\n        this._loopAnimation = false;\n        this._isAdditive = false;\n        this._weight = -1;\n        this._playOrder = 0;\n        this._enableBlending = null;\n        this._blendingSpeed = null;\n        this._numActiveAnimatables = 0;\n        this._shouldStart = true;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * This observable will notify when one animation have ended\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when one animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        /**\n         * Observer raised when all animations have looped\n         */\n        this.onAnimationGroupLoopObservable = new Observable();\n        /**\n         * This observable will notify when all animations have ended.\n         */\n        this.onAnimationGroupEndObservable = new Observable();\n        /**\n         * This observable will notify when all animations have paused.\n         */\n        this.onAnimationGroupPauseObservable = new Observable();\n        /**\n         * This observable will notify when all animations are playing.\n         */\n        this.onAnimationGroupPlayObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the node\n         */\n        this.metadata = null;\n        this._mask = null;\n        this._animationLoopFlags = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._weight = weight;\n        this._playOrder = playOrder;\n        this.uniqueId = this._scene.getUniqueId();\n        this._scene.addAnimationGroup(this);\n    }\n    /**\n     * Add an animation (with its target) in the group\n     * @param animation defines the animation we want to add\n     * @param target defines the target of the animation\n     * @returns the TargetedAnimation object\n     */\n    addTargetedAnimation(animation, target) {\n        const targetedAnimation = new TargetedAnimation();\n        targetedAnimation.animation = animation;\n        targetedAnimation.target = target;\n        const keys = animation.getKeys();\n        if (this._from > keys[0].frame) {\n            this._from = keys[0].frame;\n        }\n        if (this._to < keys[keys.length - 1].frame) {\n            this._to = keys[keys.length - 1].frame;\n        }\n        if (this._enableBlending !== null) {\n            animation.enableBlending = this._enableBlending;\n        }\n        if (this._blendingSpeed !== null) {\n            animation.blendingSpeed = this._blendingSpeed;\n        }\n        this._targetedAnimations.push(targetedAnimation);\n        this._shouldStart = true;\n        return targetedAnimation;\n    }\n    /**\n     * Remove an animation from the group\n     * @param animation defines the animation we want to remove\n     */\n    removeTargetedAnimation(animation) {\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (targetedAnimation.animation === animation) {\n                this._targetedAnimations.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n     * It can add constant keys at begin or end\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n     * @returns the animation group\n     */\n    normalize(beginFrame = null, endFrame = null) {\n        if (beginFrame == null) {\n            beginFrame = this._from;\n        }\n        if (endFrame == null) {\n            endFrame = this._to;\n        }\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const keys = targetedAnimation.animation.getKeys();\n            const startKey = keys[0];\n            const endKey = keys[keys.length - 1];\n            if (startKey.frame > beginFrame) {\n                const newKey = {\n                    frame: beginFrame,\n                    value: startKey.value,\n                    inTangent: startKey.inTangent,\n                    outTangent: startKey.outTangent,\n                    interpolation: startKey.interpolation,\n                };\n                keys.splice(0, 0, newKey);\n            }\n            if (endKey.frame < endFrame) {\n                const newKey = {\n                    frame: endFrame,\n                    value: endKey.value,\n                    inTangent: endKey.inTangent,\n                    outTangent: endKey.outTangent,\n                    interpolation: endKey.interpolation,\n                };\n                keys.push(newKey);\n            }\n        }\n        this._from = beginFrame;\n        this._to = endFrame;\n        return this;\n    }\n    _processLoop(animatable, targetedAnimation, index) {\n        animatable.onAnimationLoop = () => {\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n            if (this._animationLoopFlags[index]) {\n                return;\n            }\n            this._animationLoopFlags[index] = true;\n            this._animationLoopCount++;\n            if (this._animationLoopCount === this._numActiveAnimatables) {\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\n                this._animationLoopCount = 0;\n                this._animationLoopFlags.length = 0;\n            }\n        };\n    }\n    /**\n     * Start all animations on given targets\n     * @param loop defines if animations must loop\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n     * @param from defines the from key (optional)\n     * @param to defines the to key (optional)\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\n     * @returns the current animation group\n     */\n    start(loop = false, speedRatio = 1, from, to, isAdditive) {\n        if (this._isStarted || this._targetedAnimations.length === 0) {\n            return this;\n        }\n        this._loopAnimation = loop;\n        this._shouldStart = false;\n        this._animationLoopCount = 0;\n        this._animationLoopFlags.length = 0;\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this._from, to !== undefined ? to : this._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this._isAdditive);\n            animatable.weight = this._weight;\n            animatable.playOrder = this._playOrder;\n            animatable.onAnimationEnd = () => {\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n                this._checkAnimationGroupEnded(animatable);\n            };\n            this._processLoop(animatable, targetedAnimation, index);\n            this._animatables.push(animatable);\n        }\n        this.syncWithMask();\n        this._scene.sortActiveAnimatables();\n        this._speedRatio = speedRatio;\n        this._isStarted = true;\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Pause all animations\n     * @returns the animation group\n     */\n    pause() {\n        if (!this._isStarted) {\n            return this;\n        }\n        this._isPaused = true;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.pause();\n        }\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Play all animations to initial state\n     * This function will start() the animations if they were not started or will restart() them if they were paused\n     * @param loop defines if animations must loop\n     * @returns the animation group\n     */\n    play(loop) {\n        // only if there are animatable available\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\n            if (loop !== undefined) {\n                this.loopAnimation = loop;\n            }\n            this.restart();\n        }\n        else {\n            this.stop();\n            this.start(loop, this._speedRatio);\n        }\n        return this;\n    }\n    /**\n     * Reset all animations to initial state\n     * @returns the animation group\n     */\n    reset() {\n        if (!this._isStarted) {\n            this.play();\n            this.goToFrame(0);\n            this.stop(true);\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.reset();\n        }\n        return this;\n    }\n    /**\n     * Restart animations from after pausing it\n     * @returns the animation group\n     */\n    restart() {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.restart();\n        }\n        this.syncWithMask();\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Stop all animations\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     * @returns the animation group\n     */\n    stop(skipOnAnimationEnd = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        const list = this._animatables.slice();\n        for (let index = 0; index < list.length; index++) {\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\n        }\n        // We will take care of removing all stopped animatables\n        let curIndex = 0;\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\n            const animatable = this._scene._activeAnimatables[index];\n            if (animatable._runtimeAnimations.length > 0) {\n                this._scene._activeAnimatables[curIndex++] = animatable;\n            }\n            else if (skipOnAnimationEnd) {\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\n            }\n        }\n        this._scene._activeAnimatables.length = curIndex;\n        this._isStarted = false;\n        return this;\n    }\n    /**\n     * Set animation weight for all animatables\n     *\n     * @since 6.12.4\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\n     * @param weight defines the weight to use\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    setWeightForAllAnimatables(weight) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.weight = weight;\n        }\n        return this;\n    }\n    /**\n     * Synchronize and normalize all animatables with a source animatable\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    syncAllAnimationsWith(root) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.syncWith(root);\n        }\n        return this;\n    }\n    /**\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\n     * @param frame the frame number to go to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     * @returns the animationGroup\n     */\n    goToFrame(frame, useWeight = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.goToFrame(frame, useWeight);\n        }\n        return this;\n    }\n    /**\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\n     * @returns current animation frame.\n     */\n    getCurrentFrame() {\n        return this.animatables[0]?.masterFrame || 0;\n    }\n    /**\n     * Dispose all associated resources\n     */\n    dispose() {\n        if (this.isStarted) {\n            this.stop();\n        }\n        this._targetedAnimations.length = 0;\n        this._animatables.length = 0;\n        // Remove from scene\n        const index = this._scene.animationGroups.indexOf(this);\n        if (index > -1) {\n            this._scene.animationGroups.splice(index, 1);\n        }\n        if (this._parentContainer) {\n            const index = this._parentContainer.animationGroups.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.animationGroups.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        this.onAnimationEndObservable.clear();\n        this.onAnimationGroupEndObservable.clear();\n        this.onAnimationGroupPauseObservable.clear();\n        this.onAnimationGroupPlayObservable.clear();\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationGroupLoopObservable.clear();\n    }\n    _checkAnimationGroupEnded(animatable, skipOnAnimationEnd = false) {\n        // animatable should be taken out of the array\n        const idx = this._animatables.indexOf(animatable);\n        if (idx > -1) {\n            this._animatables.splice(idx, 1);\n        }\n        // all animatables were removed? animation group ended!\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\n            this._isStarted = false;\n            if (!skipOnAnimationEnd) {\n                this.onAnimationGroupEndObservable.notifyObservers(this);\n            }\n            this._animatables.length = 0;\n        }\n    }\n    /**\n     * Clone the current animation group and returns a copy\n     * @param newName defines the name of the new group\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\n     * @param cloneAnimations defines if the animations should be cloned or referenced\n     * @returns the new animation group\n     */\n    clone(newName, targetConverter, cloneAnimations = false) {\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\n        newGroup._from = this.from;\n        newGroup._to = this.to;\n        newGroup._speedRatio = this.speedRatio;\n        newGroup._loopAnimation = this.loopAnimation;\n        newGroup._isAdditive = this.isAdditive;\n        newGroup._enableBlending = this.enableBlending;\n        newGroup._blendingSpeed = this.blendingSpeed;\n        newGroup.metadata = this.metadata;\n        newGroup.mask = this.mask;\n        for (const targetAnimation of this._targetedAnimations) {\n            newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n        }\n        return newGroup;\n    }\n    /**\n     * Serializes the animationGroup to an object\n     * @returns Serialized object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.from = this.from;\n        serializationObject.to = this.to;\n        serializationObject.speedRatio = this.speedRatio;\n        serializationObject.loopAnimation = this.loopAnimation;\n        serializationObject.isAdditive = this.isAdditive;\n        serializationObject.weight = this.weight;\n        serializationObject.playOrder = this.playOrder;\n        serializationObject.enableBlending = this.enableBlending;\n        serializationObject.blendingSpeed = this.blendingSpeed;\n        serializationObject.targetedAnimations = [];\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n        }\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        // Metadata\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        return serializationObject;\n    }\n    // Statics\n    /**\n     * Returns a new AnimationGroup object parsed from the source provided.\n     * @param parsedAnimationGroup defines the source\n     * @param scene defines the scene that will receive the animationGroup\n     * @returns a new AnimationGroup\n     */\n    static Parse(parsedAnimationGroup, scene) {\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n            const animation = Animation.Parse(targetedAnimation.animation);\n            const id = targetedAnimation.targetId;\n            if (targetedAnimation.animation.property === \"influence\") {\n                // morph target animation\n                const morphTarget = scene.getMorphTargetById(id);\n                if (morphTarget) {\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\n                }\n            }\n            else {\n                const targetNode = scene.getNodeById(id);\n                if (targetNode != null) {\n                    animationGroup.addTargetedAnimation(animation, targetNode);\n                }\n            }\n        }\n        if (Tags) {\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n        }\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n        }\n        if (parsedAnimationGroup.speedRatio !== undefined) {\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\n        }\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\n        }\n        if (parsedAnimationGroup.isAdditive !== undefined) {\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\n        }\n        if (parsedAnimationGroup.weight !== undefined) {\n            animationGroup._weight = parsedAnimationGroup.weight;\n        }\n        if (parsedAnimationGroup.playOrder !== undefined) {\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\n        }\n        if (parsedAnimationGroup.enableBlending !== undefined) {\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\n        }\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\n        }\n        if (parsedAnimationGroup.metadata !== undefined) {\n            animationGroup.metadata = parsedAnimationGroup.metadata;\n        }\n        return animationGroup;\n    }\n    /** @internal */\n    static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n        let options;\n        if (typeof referenceFrameOrOptions === \"object\") {\n            options = referenceFrameOrOptions;\n        }\n        else {\n            options = {\n                referenceFrame: referenceFrameOrOptions,\n                range: range,\n                cloneOriginalAnimationGroup: cloneOriginal,\n                clonedAnimationName: clonedName,\n            };\n        }\n        let animationGroup = sourceAnimationGroup;\n        if (options.cloneOriginalAnimationGroup) {\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\n        }\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\n        }\n        animationGroup.isAdditive = true;\n        if (options.clipKeys) {\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\n            let from = Number.MAX_VALUE;\n            let to = -Number.MAX_VALUE;\n            const targetedAnimations = animationGroup.targetedAnimations;\n            for (let index = 0; index < targetedAnimations.length; index++) {\n                const targetedAnimation = targetedAnimations[index];\n                const animation = targetedAnimation.animation;\n                const keys = animation.getKeys();\n                if (from > keys[0].frame) {\n                    from = keys[0].frame;\n                }\n                if (to < keys[keys.length - 1].frame) {\n                    to = keys[keys.length - 1].frame;\n                }\n            }\n            animationGroup._from = from;\n            animationGroup._to = to;\n        }\n        return animationGroup;\n    }\n    /**\n     * Creates a new animation, keeping only the keys that are inside a given key range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the keys outside the given range\n     */\n    static ClipKeys(sourceAnimationGroup, fromKey, toKey, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\n    }\n    /**\n     * Creates a new animation, keeping only the frames that are inside a given frame range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the frames outside the given range\n     */\n    static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the frames outside the given range\n     */\n    static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param start defines the lower bound of the range\n     * @param end defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {\n        let from = Number.MAX_VALUE;\n        let to = -Number.MAX_VALUE;\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\n            if (useFrame) {\n                // Make sure we have keys corresponding to the bounds of the frame range\n                animation.createKeyForFrame(start);\n                animation.createKeyForFrame(end);\n            }\n            const keys = animation.getKeys();\n            const newKeys = [];\n            let startFrame = Number.MAX_VALUE;\n            for (let k = 0; k < keys.length; k++) {\n                const key = keys[k];\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\n                    const newKey = {\n                        frame: key.frame,\n                        value: key.value.clone ? key.value.clone() : key.value,\n                        inTangent: key.inTangent,\n                        outTangent: key.outTangent,\n                        interpolation: key.interpolation,\n                        lockedTangent: key.lockedTangent,\n                    };\n                    if (startFrame === Number.MAX_VALUE) {\n                        startFrame = newKey.frame;\n                    }\n                    newKey.frame -= startFrame;\n                    newKeys.push(newKey);\n                }\n            }\n            if (newKeys.length === 0) {\n                targetedAnimations.splice(index, 1);\n                index--;\n                continue;\n            }\n            if (from > newKeys[0].frame) {\n                from = newKeys[0].frame;\n            }\n            if (to < newKeys[newKeys.length - 1].frame) {\n                to = newKeys[newKeys.length - 1].frame;\n            }\n            animation.setKeys(newKeys, true);\n            targetedAnimation.animation = animation; // in case the animation has been cloned\n        }\n        animationGroup._from = from;\n        animationGroup._to = to;\n        return animationGroup;\n    }\n    /**\n     * Returns the string \"AnimationGroup\"\n     * @returns \"AnimationGroup\"\n     */\n    getClassName() {\n        return \"AnimationGroup\";\n    }\n    /**\n     * Creates a detailed string about the object\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n     * @returns a string representing the object\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + this.getClassName();\n        if (fullDetails) {\n            ret += \", from: \" + this._from;\n            ret += \", to: \" + this._to;\n            ret += \", isStarted: \" + this._isStarted;\n            ret += \", speedRatio: \" + this._speedRatio;\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n            ret += \", animatables length: \" + this._animatables;\n        }\n        return ret;\n    }\n}\n//# sourceMappingURL=animationGroup.js.map"],"names":["TargetedAnimation","serializationObject","AnimationGroup","value","forceUpdate","i","animatable","index","targetedAnimation","from","to","fps","animationGroups","disposeSource","normalize","weight","beginFrame","endFrame","animationGroup","mergedAnimationGroup","name","scene","playOrder","Observable","EngineStore","animation","target","keys","startKey","endKey","newKey","loop","speedRatio","isAdditive","skipOnAnimationEnd","list","curIndex","root","frame","useWeight","idx","newName","targetConverter","cloneAnimations","newGroup","targetAnimation","targetedAnimationIndex","Tags","parsedAnimationGroup","Animation","id","morphTarget","targetNode","sourceAnimationGroup","referenceFrameOrOptions","range","cloneOriginal","clonedName","options","targetedAnimations","fromKey","toKey","dontCloneAnimations","fromFrame","toFrame","start","end","useFrame","newKeys","startFrame","k","key","fullDetails","ret"],"mappings":"6DAQO,MAAMA,CAAkB,CAK3B,cAAe,CACX,MAAO,mBACX,CAKA,WAAY,CACR,MAAMC,EAAsB,CAAA,EAC5B,OAAAA,EAAoB,UAAY,KAAK,UAAU,UAAS,EACxDA,EAAoB,SAAW,KAAK,OAAO,GACpCA,CACX,CACJ,CAIO,MAAMC,CAAe,CAIxB,IAAI,MAAO,CACP,OAAO,KAAK,KAChB,CACA,IAAI,KAAKC,EAAO,CACR,KAAK,QAAUA,IAGnB,KAAK,MAAQA,EACb,KAAK,aAAa,EAAI,EAC1B,CAMA,aAAaC,EAAc,GAAO,CAC9B,GAAI,CAAC,KAAK,MAAQ,CAACA,EAAa,CAC5B,KAAK,sBAAwB,KAAK,oBAAoB,OACtD,MACJ,CACA,KAAK,sBAAwB,EAC7B,QAASC,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQ,EAAEA,EAAG,CAC/C,MAAMC,EAAa,KAAK,aAAaD,CAAC,EAClC,CAAC,KAAK,MAAQ,KAAK,KAAK,UAAY,KAAK,KAAK,cAAcC,EAAW,OAAO,IAAI,GAClF,KAAK,wBACDA,EAAW,QACXA,EAAW,QAAO,GAIjBA,EAAW,QACZA,EAAW,MAAK,CAG5B,CACJ,CAKA,0BAA2B,CACvB,GAAI,GAAC,KAAK,MAAQ,KAAK,KAAK,UAI5B,SAASD,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQ,EAAEA,EAAG,CAC/C,MAAMC,EAAa,KAAK,aAAaD,CAAC,EACjC,KAAK,KAAK,cAAcC,EAAW,OAAO,IAAI,IAC/CA,EAAW,KAAI,EACf,KAAK,aAAa,OAAOD,EAAG,CAAC,EAC7B,EAAEA,EAEV,CAEA,QAASE,EAAQ,EAAGA,EAAQ,KAAK,oBAAoB,OAAQA,IAAS,CAClE,MAAMC,EAAoB,KAAK,oBAAoBD,CAAK,EACnD,KAAK,KAAK,cAAcC,EAAkB,OAAO,IAAI,IACtD,KAAK,oBAAoB,OAAOD,EAAO,CAAC,EACxC,EAAEA,EAEV,EACJ,CAIA,IAAI,MAAO,CACP,OAAO,KAAK,KAChB,CACA,IAAI,KAAKJ,EAAO,CACZ,GAAI,KAAK,QAAUA,EAGnB,MAAK,MAAQA,EACb,QAASI,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAAS,CAC3D,MAAMD,EAAa,KAAK,aAAaC,CAAK,EAC1CD,EAAW,UAAY,KAAK,KAChC,EACJ,CAIA,IAAI,IAAK,CACL,OAAO,KAAK,GAChB,CACA,IAAI,GAAGH,EAAO,CACV,GAAI,KAAK,MAAQA,EAGjB,MAAK,IAAMA,EACX,QAASI,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAAS,CAC3D,MAAMD,EAAa,KAAK,aAAaC,CAAK,EAC1CD,EAAW,QAAU,KAAK,GAC9B,EACJ,CAIA,IAAI,WAAY,CACZ,OAAO,KAAK,UAChB,CAIA,IAAI,WAAY,CACZ,OAAO,KAAK,YAAc,CAAC,KAAK,SACpC,CAIA,IAAI,YAAa,CACb,OAAO,KAAK,WAChB,CAIA,IAAI,WAAWH,EAAO,CAClB,GAAI,KAAK,cAAgBA,EAGzB,MAAK,YAAcA,EACnB,QAASI,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAAS,CAC3D,MAAMD,EAAa,KAAK,aAAaC,CAAK,EAC1CD,EAAW,WAAa,KAAK,WACjC,EACJ,CAIA,IAAI,eAAgB,CAChB,OAAO,KAAK,cAChB,CACA,IAAI,cAAcH,EAAO,CACrB,GAAI,KAAK,iBAAmBA,EAG5B,MAAK,eAAiBA,EACtB,QAASI,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAAS,CAC3D,MAAMD,EAAa,KAAK,aAAaC,CAAK,EAC1CD,EAAW,cAAgB,KAAK,cACpC,EACJ,CAIA,IAAI,YAAa,CACb,OAAO,KAAK,WAChB,CACA,IAAI,WAAWH,EAAO,CAClB,GAAI,KAAK,cAAgBA,EAGzB,MAAK,YAAcA,EACnB,QAASI,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAAS,CAC3D,MAAMD,EAAa,KAAK,aAAaC,CAAK,EAC1CD,EAAW,WAAa,KAAK,WACjC,EACJ,CAIA,IAAI,QAAS,CACT,OAAO,KAAK,OAChB,CACA,IAAI,OAAOH,EAAO,CACV,KAAK,UAAYA,IAGrB,KAAK,QAAUA,EACf,KAAK,2BAA2B,KAAK,OAAO,EAChD,CAIA,IAAI,oBAAqB,CACrB,OAAO,KAAK,mBAChB,CAIA,IAAI,aAAc,CACd,OAAO,KAAK,YAChB,CAIA,IAAI,UAAW,CACX,OAAO,KAAK,mBAChB,CAIA,IAAI,WAAY,CACZ,OAAO,KAAK,UAChB,CACA,IAAI,UAAUA,EAAO,CACjB,GAAI,KAAK,aAAeA,IAGxB,KAAK,WAAaA,EACd,KAAK,aAAa,OAAS,GAAG,CAC9B,QAASE,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQA,IAC1C,KAAK,aAAaA,CAAC,EAAE,UAAY,KAAK,WAE1C,KAAK,OAAO,sBAAqB,CACrC,CACJ,CAKA,IAAI,gBAAiB,CACjB,OAAO,KAAK,eAChB,CACA,IAAI,eAAeF,EAAO,CACtB,GAAI,KAAK,kBAAoBA,IAG7B,KAAK,gBAAkBA,EACnBA,IAAU,MACV,QAASE,EAAI,EAAGA,EAAI,KAAK,oBAAoB,OAAQ,EAAEA,EACnD,KAAK,oBAAoBA,CAAC,EAAE,UAAU,eAAiBF,CAGnE,CAKA,IAAI,eAAgB,CAChB,OAAO,KAAK,cAChB,CACA,IAAI,cAAcA,EAAO,CACrB,GAAI,KAAK,iBAAmBA,IAG5B,KAAK,eAAiBA,EAClBA,IAAU,MACV,QAASE,EAAI,EAAGA,EAAI,KAAK,oBAAoB,OAAQ,EAAEA,EACnD,KAAK,oBAAoBA,CAAC,EAAE,UAAU,cAAgBF,CAGlE,CASA,UAAUM,EAAMC,EAAI,CAChBD,EAAOA,GAAQ,KAAK,MACpBC,EAAKA,GAAM,KAAK,IAChB,MAAMC,EAAM,KAAK,mBAAmB,CAAC,EAAE,UAAU,eAAiB,KAAK,YACvE,OAAQD,EAAKD,GAAQE,CACzB,CASA,OAAO,qBAAqBC,EAAiBC,EAAgB,GAAMC,EAAY,GAAOC,EAAQ,CAC1F,GAAIH,EAAgB,SAAW,EAC3B,OAAO,KAEXG,EAASA,GAAUH,EAAgB,CAAC,EAAE,OACtC,IAAII,EAAa,OAAO,UACpBC,EAAW,CAAC,OAAO,UACvB,GAAIH,EACA,UAAWI,KAAkBN,EACrBM,EAAe,KAAOF,IACtBA,EAAaE,EAAe,MAE5BA,EAAe,GAAKD,IACpBA,EAAWC,EAAe,IAItC,MAAMC,EAAuB,IAAIjB,EAAeU,EAAgB,CAAC,EAAE,KAAO,UAAWA,EAAgB,CAAC,EAAE,OAAQG,CAAM,EACtH,UAAWG,KAAkBN,EAAiB,CACtCE,GACAI,EAAe,UAAUF,EAAYC,CAAQ,EAEjD,UAAWT,KAAqBU,EAAe,mBAC3CC,EAAqB,qBAAqBX,EAAkB,UAAWA,EAAkB,MAAM,EAE/FK,GACAK,EAAe,QAAO,CAE9B,CACA,OAAOC,CACX,CAUA,YAEAC,EAAMC,EAAQ,KAAMN,EAAS,GAAIO,EAAY,EAAG,CAC5C,KAAK,KAAOF,EACZ,KAAK,oBAAsB,IAAI,MAC/B,KAAK,aAAe,IAAI,MACxB,KAAK,MAAQ,OAAO,UACpB,KAAK,IAAM,CAAC,OAAO,UACnB,KAAK,YAAc,EACnB,KAAK,eAAiB,GACtB,KAAK,YAAc,GACnB,KAAK,QAAU,GACf,KAAK,WAAa,EAClB,KAAK,gBAAkB,KACvB,KAAK,eAAiB,KACtB,KAAK,sBAAwB,EAC7B,KAAK,aAAe,GAEpB,KAAK,iBAAmB,KAIxB,KAAK,yBAA2B,IAAIG,EAIpC,KAAK,0BAA4B,IAAIA,EAIrC,KAAK,+BAAiC,IAAIA,EAI1C,KAAK,8BAAgC,IAAIA,EAIzC,KAAK,gCAAkC,IAAIA,EAI3C,KAAK,+BAAiC,IAAIA,EAI1C,KAAK,SAAW,KAChB,KAAK,MAAQ,KACb,KAAK,oBAAsB,CAAA,EAC3B,KAAK,OAASF,GAASG,EAAY,iBACnC,KAAK,QAAUT,EACf,KAAK,WAAaO,EAClB,KAAK,SAAW,KAAK,OAAO,YAAW,EACvC,KAAK,OAAO,kBAAkB,IAAI,CACtC,CAOA,qBAAqBG,EAAWC,EAAQ,CACpC,MAAMlB,EAAoB,IAAIR,EAC9BQ,EAAkB,UAAYiB,EAC9BjB,EAAkB,OAASkB,EAC3B,MAAMC,EAAOF,EAAU,QAAO,EAC9B,OAAI,KAAK,MAAQE,EAAK,CAAC,EAAE,QACrB,KAAK,MAAQA,EAAK,CAAC,EAAE,OAErB,KAAK,IAAMA,EAAKA,EAAK,OAAS,CAAC,EAAE,QACjC,KAAK,IAAMA,EAAKA,EAAK,OAAS,CAAC,EAAE,OAEjC,KAAK,kBAAoB,OACzBF,EAAU,eAAiB,KAAK,iBAEhC,KAAK,iBAAmB,OACxBA,EAAU,cAAgB,KAAK,gBAEnC,KAAK,oBAAoB,KAAKjB,CAAiB,EAC/C,KAAK,aAAe,GACbA,CACX,CAKA,wBAAwBiB,EAAW,CAC/B,QAASlB,EAAQ,KAAK,oBAAoB,OAAS,EAAGA,EAAQ,GAAIA,IACpC,KAAK,oBAAoBA,CAAK,EAClC,YAAckB,GAChC,KAAK,oBAAoB,OAAOlB,EAAO,CAAC,CAGpD,CAQA,UAAUS,EAAa,KAAMC,EAAW,KAAM,CACtCD,GAAc,OACdA,EAAa,KAAK,OAElBC,GAAY,OACZA,EAAW,KAAK,KAEpB,QAASV,EAAQ,EAAGA,EAAQ,KAAK,oBAAoB,OAAQA,IAAS,CAElE,MAAMoB,EADoB,KAAK,oBAAoBpB,CAAK,EACzB,UAAU,QAAO,EAC1CqB,EAAWD,EAAK,CAAC,EACjBE,EAASF,EAAKA,EAAK,OAAS,CAAC,EACnC,GAAIC,EAAS,MAAQZ,EAAY,CAC7B,MAAMc,EAAS,CACX,MAAOd,EACP,MAAOY,EAAS,MAChB,UAAWA,EAAS,UACpB,WAAYA,EAAS,WACrB,cAAeA,EAAS,aAC5C,EACgBD,EAAK,OAAO,EAAG,EAAGG,CAAM,CAC5B,CACA,GAAID,EAAO,MAAQZ,EAAU,CACzB,MAAMa,EAAS,CACX,MAAOb,EACP,MAAOY,EAAO,MACd,UAAWA,EAAO,UAClB,WAAYA,EAAO,WACnB,cAAeA,EAAO,aAC1C,EACgBF,EAAK,KAAKG,CAAM,CACpB,CACJ,CACA,YAAK,MAAQd,EACb,KAAK,IAAMC,EACJ,IACX,CACA,aAAaX,EAAYE,EAAmBD,EAAO,CAC/CD,EAAW,gBAAkB,IAAM,CAC/B,KAAK,0BAA0B,gBAAgBE,CAAiB,EAC5D,MAAK,oBAAoBD,CAAK,IAGlC,KAAK,oBAAoBA,CAAK,EAAI,GAClC,KAAK,sBACD,KAAK,sBAAwB,KAAK,wBAClC,KAAK,+BAA+B,gBAAgB,IAAI,EACxD,KAAK,oBAAsB,EAC3B,KAAK,oBAAoB,OAAS,GAE1C,CACJ,CAUA,MAAMwB,EAAO,GAAOC,EAAa,EAAGvB,EAAMC,EAAIuB,EAAY,CACtD,GAAI,KAAK,YAAc,KAAK,oBAAoB,SAAW,EACvD,OAAO,KAEX,KAAK,eAAiBF,EACtB,KAAK,aAAe,GACpB,KAAK,oBAAsB,EAC3B,KAAK,oBAAoB,OAAS,EAClC,QAASxB,EAAQ,EAAGA,EAAQ,KAAK,oBAAoB,OAAQA,IAAS,CAClE,MAAMC,EAAoB,KAAK,oBAAoBD,CAAK,EAClDD,EAAa,KAAK,OAAO,qBAAqBE,EAAkB,OAAQ,CAACA,EAAkB,SAAS,EAAGC,IAAS,OAAYA,EAAO,KAAK,MAAOC,IAAO,OAAYA,EAAK,KAAK,IAAKqB,EAAMC,EAAY,OAAW,OAAWC,IAAe,OAAYA,EAAa,KAAK,WAAW,EACvR3B,EAAW,OAAS,KAAK,QACzBA,EAAW,UAAY,KAAK,WAC5BA,EAAW,eAAiB,IAAM,CAC9B,KAAK,yBAAyB,gBAAgBE,CAAiB,EAC/D,KAAK,0BAA0BF,CAAU,CAC7C,EACA,KAAK,aAAaA,EAAYE,EAAmBD,CAAK,EACtD,KAAK,aAAa,KAAKD,CAAU,CACrC,CACA,YAAK,aAAY,EACjB,KAAK,OAAO,sBAAqB,EACjC,KAAK,YAAc0B,EACnB,KAAK,WAAa,GAClB,KAAK,UAAY,GACjB,KAAK,+BAA+B,gBAAgB,IAAI,EACjD,IACX,CAKA,OAAQ,CACJ,GAAI,CAAC,KAAK,WACN,OAAO,KAEX,KAAK,UAAY,GACjB,QAASzB,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAC/B,KAAK,aAAaA,CAAK,EAC/B,MAAK,EAEpB,YAAK,gCAAgC,gBAAgB,IAAI,EAClD,IACX,CAOA,KAAKwB,EAAM,CAEP,OAAI,KAAK,WAAa,KAAK,aAAa,QAAU,CAAC,KAAK,cAChDA,IAAS,SACT,KAAK,cAAgBA,GAEzB,KAAK,QAAO,IAGZ,KAAK,KAAI,EACT,KAAK,MAAMA,EAAM,KAAK,WAAW,GAE9B,IACX,CAKA,OAAQ,CACJ,GAAI,CAAC,KAAK,WACN,YAAK,KAAI,EACT,KAAK,UAAU,CAAC,EAChB,KAAK,KAAK,EAAI,EACP,KAEX,QAASxB,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAC/B,KAAK,aAAaA,CAAK,EAC/B,MAAK,EAEpB,OAAO,IACX,CAKA,SAAU,CACN,GAAI,CAAC,KAAK,WACN,OAAO,KAEX,QAASA,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAC/B,KAAK,aAAaA,CAAK,EAC/B,QAAO,EAEtB,YAAK,aAAY,EACjB,KAAK,UAAY,GACjB,KAAK,+BAA+B,gBAAgB,IAAI,EACjD,IACX,CAMA,KAAK2B,EAAqB,GAAO,CAC7B,GAAI,CAAC,KAAK,WACN,OAAO,KAEX,MAAMC,EAAO,KAAK,aAAa,MAAK,EACpC,QAAS5B,EAAQ,EAAGA,EAAQ4B,EAAK,OAAQ5B,IACrC4B,EAAK5B,CAAK,EAAE,KAAK,OAAW,OAAW,GAAM2B,CAAkB,EAGnE,IAAIE,EAAW,EACf,QAAS7B,EAAQ,EAAGA,EAAQ,KAAK,OAAO,mBAAmB,OAAQA,IAAS,CACxE,MAAMD,EAAa,KAAK,OAAO,mBAAmBC,CAAK,EACnDD,EAAW,mBAAmB,OAAS,EACvC,KAAK,OAAO,mBAAmB8B,GAAU,EAAI9B,EAExC4B,GAIL,KAAK,0BAA0B5B,EAAY4B,CAAkB,CAErE,CACA,YAAK,OAAO,mBAAmB,OAASE,EACxC,KAAK,WAAa,GACX,IACX,CAWA,2BAA2BrB,EAAQ,CAC/B,QAASR,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAAS,CAC3D,MAAMD,EAAa,KAAK,aAAaC,CAAK,EAC1CD,EAAW,OAASS,CACxB,CACA,OAAO,IACX,CAOA,sBAAsBsB,EAAM,CACxB,QAAS9B,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAC/B,KAAK,aAAaA,CAAK,EAC/B,SAAS8B,CAAI,EAE5B,OAAO,IACX,CAOA,UAAUC,EAAOC,EAAY,GAAO,CAChC,GAAI,CAAC,KAAK,WACN,OAAO,KAEX,QAAShC,EAAQ,EAAGA,EAAQ,KAAK,aAAa,OAAQA,IAC/B,KAAK,aAAaA,CAAK,EAC/B,UAAU+B,EAAOC,CAAS,EAEzC,OAAO,IACX,CAKA,iBAAkB,CACd,OAAO,KAAK,YAAY,CAAC,GAAG,aAAe,CAC/C,CAIA,SAAU,CACF,KAAK,WACL,KAAK,KAAI,EAEb,KAAK,oBAAoB,OAAS,EAClC,KAAK,aAAa,OAAS,EAE3B,MAAMhC,EAAQ,KAAK,OAAO,gBAAgB,QAAQ,IAAI,EAItD,GAHIA,EAAQ,IACR,KAAK,OAAO,gBAAgB,OAAOA,EAAO,CAAC,EAE3C,KAAK,iBAAkB,CACvB,MAAMA,EAAQ,KAAK,iBAAiB,gBAAgB,QAAQ,IAAI,EAC5DA,EAAQ,IACR,KAAK,iBAAiB,gBAAgB,OAAOA,EAAO,CAAC,EAEzD,KAAK,iBAAmB,IAC5B,CACA,KAAK,yBAAyB,MAAK,EACnC,KAAK,8BAA8B,MAAK,EACxC,KAAK,gCAAgC,MAAK,EAC1C,KAAK,+BAA+B,MAAK,EACzC,KAAK,0BAA0B,MAAK,EACpC,KAAK,+BAA+B,MAAK,CAC7C,CACA,0BAA0BD,EAAY4B,EAAqB,GAAO,CAE9D,MAAMM,EAAM,KAAK,aAAa,QAAQlC,CAAU,EAC5CkC,EAAM,IACN,KAAK,aAAa,OAAOA,EAAK,CAAC,EAG/B,KAAK,aAAa,SAAW,KAAK,oBAAoB,OAAS,KAAK,wBACpE,KAAK,WAAa,GACbN,GACD,KAAK,8BAA8B,gBAAgB,IAAI,EAE3D,KAAK,aAAa,OAAS,EAEnC,CAQA,MAAMO,EAASC,EAAiBC,EAAkB,GAAO,CACrD,MAAMC,EAAW,IAAI1C,EAAeuC,GAAW,KAAK,KAAM,KAAK,OAAQ,KAAK,QAAS,KAAK,UAAU,EACpGG,EAAS,MAAQ,KAAK,KACtBA,EAAS,IAAM,KAAK,GACpBA,EAAS,YAAc,KAAK,WAC5BA,EAAS,eAAiB,KAAK,cAC/BA,EAAS,YAAc,KAAK,WAC5BA,EAAS,gBAAkB,KAAK,eAChCA,EAAS,eAAiB,KAAK,cAC/BA,EAAS,SAAW,KAAK,SACzBA,EAAS,KAAO,KAAK,KACrB,UAAWC,KAAmB,KAAK,oBAC/BD,EAAS,qBAAqBD,EAAkBE,EAAgB,UAAU,MAAK,EAAKA,EAAgB,UAAWH,EAAkBA,EAAgBG,EAAgB,MAAM,EAAIA,EAAgB,MAAM,EAErM,OAAOD,CACX,CAKA,WAAY,CACR,MAAM3C,EAAsB,CAAA,EAC5BA,EAAoB,KAAO,KAAK,KAChCA,EAAoB,KAAO,KAAK,KAChCA,EAAoB,GAAK,KAAK,GAC9BA,EAAoB,WAAa,KAAK,WACtCA,EAAoB,cAAgB,KAAK,cACzCA,EAAoB,WAAa,KAAK,WACtCA,EAAoB,OAAS,KAAK,OAClCA,EAAoB,UAAY,KAAK,UACrCA,EAAoB,eAAiB,KAAK,eAC1CA,EAAoB,cAAgB,KAAK,cACzCA,EAAoB,mBAAqB,CAAA,EACzC,QAAS6C,EAAyB,EAAGA,EAAyB,KAAK,mBAAmB,OAAQA,IAA0B,CACpH,MAAMtC,EAAoB,KAAK,mBAAmBsC,CAAsB,EACxE7C,EAAoB,mBAAmB6C,CAAsB,EAAItC,EAAkB,UAAS,CAChG,CACA,OAAIuC,GAAQA,EAAK,QAAQ,IAAI,IACzB9C,EAAoB,KAAO8C,EAAK,QAAQ,IAAI,GAG5C,KAAK,WACL9C,EAAoB,SAAW,KAAK,UAEjCA,CACX,CAQA,OAAO,MAAM+C,EAAsB3B,EAAO,CACtC,MAAMH,EAAiB,IAAIhB,EAAe8C,EAAqB,KAAM3B,EAAO2B,EAAqB,OAAQA,EAAqB,SAAS,EACvI,QAAS3C,EAAI,EAAGA,EAAI2C,EAAqB,mBAAmB,OAAQ3C,IAAK,CACrE,MAAMG,EAAoBwC,EAAqB,mBAAmB3C,CAAC,EAC7DoB,EAAYwB,EAAU,MAAMzC,EAAkB,SAAS,EACvD0C,EAAK1C,EAAkB,SAC7B,GAAIA,EAAkB,UAAU,WAAa,YAAa,CAEtD,MAAM2C,EAAc9B,EAAM,mBAAmB6B,CAAE,EAC3CC,GACAjC,EAAe,qBAAqBO,EAAW0B,CAAW,CAElE,KACK,CACD,MAAMC,EAAa/B,EAAM,YAAY6B,CAAE,EACnCE,GAAc,MACdlC,EAAe,qBAAqBO,EAAW2B,CAAU,CAEjE,CACJ,CACA,OAAIL,GACAA,EAAK,UAAU7B,EAAgB8B,EAAqB,IAAI,EAExDA,EAAqB,OAAS,MAAQA,EAAqB,KAAO,MAClE9B,EAAe,UAAU8B,EAAqB,KAAMA,EAAqB,EAAE,EAE3EA,EAAqB,aAAe,SACpC9B,EAAe,YAAc8B,EAAqB,YAElDA,EAAqB,gBAAkB,SACvC9B,EAAe,eAAiB8B,EAAqB,eAErDA,EAAqB,aAAe,SACpC9B,EAAe,YAAc8B,EAAqB,YAElDA,EAAqB,SAAW,SAChC9B,EAAe,QAAU8B,EAAqB,QAE9CA,EAAqB,YAAc,SACnC9B,EAAe,WAAa8B,EAAqB,WAEjDA,EAAqB,iBAAmB,SACxC9B,EAAe,gBAAkB8B,EAAqB,gBAEtDA,EAAqB,gBAAkB,SACvC9B,EAAe,eAAiB8B,EAAqB,eAErDA,EAAqB,WAAa,SAClC9B,EAAe,SAAW8B,EAAqB,UAE5C9B,CACX,CAEA,OAAO,sBAAsBmC,EAAsBC,EAAyBC,EAAOC,EAAgB,GAAOC,EAAY,CAClH,IAAIC,EACA,OAAOJ,GAA4B,SACnCI,EAAUJ,EAGVI,EAAU,CACN,eAAgBJ,EAChB,MAAOC,EACP,4BAA6BC,EAC7B,oBAAqBC,CACrC,EAEQ,IAAIvC,EAAiBmC,EACjBK,EAAQ,8BACRxC,EAAiBmC,EAAqB,MAAMK,EAAQ,0BAA4BxC,EAAe,IAAI,GAEvG,MAAMyC,EAAqBzC,EAAe,mBAC1C,QAASX,EAAQ,EAAGA,EAAQoD,EAAmB,OAAQpD,IAAS,CAC5D,MAAMC,EAAoBmD,EAAmBpD,CAAK,EAClDC,EAAkB,UAAYyC,EAAU,sBAAsBzC,EAAkB,UAAWkD,CAAO,CACtG,CAEA,GADAxC,EAAe,WAAa,GACxBwC,EAAQ,SAAU,CAElB,IAAIjD,EAAO,OAAO,UACdC,EAAK,CAAC,OAAO,UACjB,MAAMiD,EAAqBzC,EAAe,mBAC1C,QAASX,EAAQ,EAAGA,EAAQoD,EAAmB,OAAQpD,IAAS,CAG5D,MAAMoB,EAFoBgC,EAAmBpD,CAAK,EACd,UACb,QAAO,EAC1BE,EAAOkB,EAAK,CAAC,EAAE,QACflB,EAAOkB,EAAK,CAAC,EAAE,OAEfjB,EAAKiB,EAAKA,EAAK,OAAS,CAAC,EAAE,QAC3BjB,EAAKiB,EAAKA,EAAK,OAAS,CAAC,EAAE,MAEnC,CACAT,EAAe,MAAQT,EACvBS,EAAe,IAAMR,CACzB,CACA,OAAOQ,CACX,CAUA,OAAO,SAASmC,EAAsBO,EAASC,EAAOzC,EAAM0C,EAAqB,CAC7E,MAAM5C,EAAiBmC,EAAqB,MAAMjC,GAAQiC,EAAqB,IAAI,EACnF,OAAOnD,EAAe,gBAAgBgB,EAAgB0C,EAASC,EAAOC,CAAmB,CAC7F,CASA,OAAO,gBAAgB5C,EAAgB0C,EAASC,EAAOC,EAAqB,CACxE,OAAO5D,EAAe,YAAYgB,EAAgB0C,EAASC,EAAOC,EAAqB,EAAK,CAChG,CAUA,OAAO,WAAWT,EAAsBU,EAAWC,EAAS5C,EAAM0C,EAAqB,CACnF,MAAM5C,EAAiBmC,EAAqB,MAAMjC,GAAQiC,EAAqB,IAAI,EACnF,OAAOnD,EAAe,kBAAkBgB,EAAgB6C,EAAWC,EAASF,CAAmB,CACnG,CASA,OAAO,kBAAkB5C,EAAgB6C,EAAWC,EAASF,EAAqB,CAC9E,OAAO5D,EAAe,YAAYgB,EAAgB6C,EAAWC,EAASF,EAAqB,EAAI,CACnG,CAUA,OAAO,YAAY5C,EAAgB+C,EAAOC,EAAKJ,EAAqBK,EAAW,GAAO,CAClF,IAAI1D,EAAO,OAAO,UACdC,EAAK,CAAC,OAAO,UACjB,MAAMiD,EAAqBzC,EAAe,mBAC1C,QAASX,EAAQ,EAAGA,EAAQoD,EAAmB,OAAQpD,IAAS,CAC5D,MAAMC,EAAoBmD,EAAmBpD,CAAK,EAC5CkB,EAAYqC,EAAsBtD,EAAkB,UAAYA,EAAkB,UAAU,MAAK,EACnG2D,IAEA1C,EAAU,kBAAkBwC,CAAK,EACjCxC,EAAU,kBAAkByC,CAAG,GAEnC,MAAMvC,EAAOF,EAAU,QAAO,EACxB2C,EAAU,CAAA,EAChB,IAAIC,EAAa,OAAO,UACxB,QAASC,EAAI,EAAGA,EAAI3C,EAAK,OAAQ2C,IAAK,CAClC,MAAMC,EAAM5C,EAAK2C,CAAC,EAClB,GAAK,CAACH,GAAYG,GAAKL,GAASK,GAAKJ,GAASC,GAAYI,EAAI,OAASN,GAASM,EAAI,OAASL,EAAM,CAC/F,MAAMpC,EAAS,CACX,MAAOyC,EAAI,MACX,MAAOA,EAAI,MAAM,MAAQA,EAAI,MAAM,QAAUA,EAAI,MACjD,UAAWA,EAAI,UACf,WAAYA,EAAI,WAChB,cAAeA,EAAI,cACnB,cAAeA,EAAI,aAC3C,EACwBF,IAAe,OAAO,YACtBA,EAAavC,EAAO,OAExBA,EAAO,OAASuC,EAChBD,EAAQ,KAAKtC,CAAM,CACvB,CACJ,CACA,GAAIsC,EAAQ,SAAW,EAAG,CACtBT,EAAmB,OAAOpD,EAAO,CAAC,EAClCA,IACA,QACJ,CACIE,EAAO2D,EAAQ,CAAC,EAAE,QAClB3D,EAAO2D,EAAQ,CAAC,EAAE,OAElB1D,EAAK0D,EAAQA,EAAQ,OAAS,CAAC,EAAE,QACjC1D,EAAK0D,EAAQA,EAAQ,OAAS,CAAC,EAAE,OAErC3C,EAAU,QAAQ2C,EAAS,EAAI,EAC/B5D,EAAkB,UAAYiB,CAClC,CACA,OAAAP,EAAe,MAAQT,EACvBS,EAAe,IAAMR,EACdQ,CACX,CAKA,cAAe,CACX,MAAO,gBACX,CAMA,SAASsD,EAAa,CAClB,IAAIC,EAAM,SAAW,KAAK,KAC1B,OAAAA,GAAO,WAAa,KAAK,aAAY,EACjCD,IACAC,GAAO,WAAa,KAAK,MACzBA,GAAO,SAAW,KAAK,IACvBA,GAAO,gBAAkB,KAAK,WAC9BA,GAAO,iBAAmB,KAAK,YAC/BA,GAAO,gCAAkC,KAAK,oBAAoB,OAClEA,GAAO,yBAA2B,KAAK,cAEpCA,CACX,CACJ","x_google_ignoreList":[0]}