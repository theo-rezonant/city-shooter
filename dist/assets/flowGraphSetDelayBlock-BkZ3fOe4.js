import{a as c,b as o,C as u,L as h,d as g}from"./index-gCZdN4BF.js";class t extends c{constructor(e){super(e),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",o),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",o,-1)}_preparePendingTasks(e){const a=this.duration.getValue(e);if(a<0||isNaN(a)||!isFinite(a))return this._reportError(e,"Invalid duration in SetDelay block");if(e._getGlobalContextVariable("activeDelays",0)>=t.MaxParallelDelayCount)return this._reportError(e,"Max parallel delays reached");const i=e._getGlobalContextVariable("lastDelayIndex",-1),r=e._getExecutionVariable(this,"pendingDelays",[]),d=e.configuration.scene,n=new u({timeout:a*1e3,contextObservable:d.onBeforeRenderObservable,onEnded:()=>this._onEnded(n,e)});n.start();const l=i+1;this.lastDelayIndex.setValue(l,e),e._setGlobalContextVariable("lastDelayIndex",l),r[l]=n,e._setExecutionVariable(this,"pendingDelays",r)}_cancelPendingTasks(e){const a=e._getExecutionVariable(this,"pendingDelays",[]);for(const s of a)s?.dispose();e._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(-1,e)}_execute(e,a){if(a===this.cancel){this._cancelPendingTasks(e);return}else this._preparePendingTasks(e),this.out._activateSignal(e)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(e,a){const s=a._getExecutionVariable(this,"pendingDelays",[]),i=s.indexOf(e);i!==-1?s.splice(i,1):h.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),a._removePendingBlock(this),this.done._activateSignal(a)}}t.MaxParallelDelayCount=100;g("FlowGraphSetDelayBlock",t);export{t as FlowGraphSetDelayBlock};
//# sourceMappingURL=flowGraphSetDelayBlock-BkZ3fOe4.js.map
